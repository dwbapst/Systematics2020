<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title> • Systematics2020</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/all.min.css" integrity="sha256-nAmazAk6vS34Xqo0BSrTb+abbtFlgsFK7NKSi6o7Y78=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/v4-shims.min.css" integrity="sha256-6qHlizsOWFskGlwVOKuns+D1nB6ssZrHQrNj1wGplHc=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/headroom.min.js" integrity="sha256-DJFC1kqIhelURkuza0AvYal5RxMtpzLjFhsnVIeuk+U=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../../pkgdown.css" rel="stylesheet">
<script src="../../pkgdown.js"></script><meta property="og:title" content="">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../../index.html">Systematics2020</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../../articles/00_Basics_of_R/index.html">UNKNOWN TITLE</a>
    </li>
    <li>
      <a href="../../articles/01_tutorial_structure/index.html">Setting Up RevBayes</a>
    </li>
    <li>
      <a href="../../articles/02_CTMC/index.html">Nucleotide substitution models</a>
    </li>
    <li>
      <a href="../../articles/03_Discrete_Morphology/05_RB_MCMC_Discrete_Morph.html">Discrete morphology - Models and Tree Inference</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1></h1>
            
      
      
      <div class="hidden name"><code>index.Rmd</code></div>

    </div>

    
    
<div id="chapter-one-an-introduction-to-project-organization" class="section level1">
<h1 class="hasAnchor">
<a href="#chapter-one-an-introduction-to-project-organization" class="anchor"></a>Chapter One: An Introduction to Project Organization</h1>
<div id="introduction-how-can-we-maintain-tractable-data-structures-for-use-with-phylogenetic" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction-how-can-we-maintain-tractable-data-structures-for-use-with-phylogenetic" class="anchor"></a>Introduction: How can we maintain tractable data structures for use with phylogenetic</h2>
<p>projects?</p>
<p>“I just wasted five hours running an analysis on the wrong input file.”</p>
<p>“I can’t remember where I saved my output.”</p>
<p>“I accidentally overwrote my raw data.”</p>
<p>Many of us have probably said one or more of the above sentences. When you’re balancing multiple projects and lots of data, it can be easy to lose track of files. One of the biggest challenges to any project is placing project files in a structure that is easy for you, the scientist, to access and maintain.</p>
<p>This chapter will cover the basics of project organization and data organization and management. At the end of this chapter, you should be familiar with:</p>
<ol style="list-style-type: decimal">
<li>
<em>Concept:</em> How to store project input files, scripts and project outputs</li>
<li>
<em>Concept:</em> How to organize your data in a way that is reusable for you, and for others</li>
<li>
<em>Hands-On:</em> How to use the command line to create directories, move files and view the files that you have</li>
</ol>
</div>
<div id="creating-project-workspaces" class="section level2">
<h2 class="hasAnchor">
<a href="#creating-project-workspaces" class="anchor"></a>Creating Project Workspaces</h2>
<p>This book will discuss not solely the Dendropy computing library, but efficient R computation for phylogenetic analyses. In this section, we are going to address a very specific aim: setting up projects on your computer in a way that will allow you to manage your projects efficiently. We will use hands-on examples throughout this section.</p>
<p>When managing a project, you want to <em>keep files together as much as possible</em>. Doing this makes it easier to document your project, and avoid losing data files.</p>
<p>Create an R Project together</p>
<p>Make two subdirectories: code and data</p>
<p>These four subdirectories will all serve important purposes. Our scripts directory will house the R code we will write. We will talk in further chapters about why it is important and useful to keep all of the scripts for a single project together. For now, just know that it is.</p>
<p>Our data directory will house our raw data. We want our raw data to be housed on its own. If we make a mistake in how we save output files, we can always go back to our raw data and run the analysis again … so long as we have maintained the integrity of our raw data. Once we have populated our data directory with the necessary data, we do not write to it. A simple motto for this philosophy is that <em>data are read-only</em>.</p>
<p>We do, however, write to our output directory. We will talk in future chapters about using R to make readable and informative output file names. For now, just know that the results of <em>any</em> analysis go in the output directory.</p>
<p>Documentation is where we can put miscellaneous, informative files. For example, papers that you are reading for your project, cost sheets for sequencing, talk slides.</p>
<p>This is the basic setup all chapters of this book will rely on. This manner of file organization is very transparent: anyone looking at your file directory can understand what components of your research project are stored where. If you follow this structure, when you go to publish your paper, you can simply archive your entire project directory to meet most funders’ and journal’s guidelines for providing data and software code. And who couldn’t use a little less on their plate when it comes time to submit a paper?</p>
<div id="recap-our-three-goals" class="section level3">
<h3 class="hasAnchor">
<a href="#recap-our-three-goals" class="anchor"></a>Recap: Our Three Goals</h3>
<p>So far, we have introduced two important concepts: <em>keep files together as much as possible</em> and <em>data are read-only</em>. The first principle means to keep data, output and code related to one project in one place on your computer to increase your organization. The second principle means to treat raw data as untouchable. Any outputs of analyses should be kept separate to avoid loss of data, and to ensure you can rerun any steps as needed.</p>
<p>In learning these two concepts, we have used hands-on commands: mkdir to create directories, ls to look at their contents and cd to navigate. We also learned to check our navigation with the pwd command and to use tab-complete to increase the efficiency of our typing.</p>
</div>
</div>
</div>
<div id="chapter-two-moving-from-spreadsheets-to-r" class="section level1">
<h1 class="hasAnchor">
<a href="#chapter-two-moving-from-spreadsheets-to-r" class="anchor"></a>Chapter Two: Moving From Spreadsheets to R</h1>
<div id="introduction" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h2>
<p>“I know I made a plot of this … I just can’t remember how.”</p>
<p>“This looks totally different on my computer.”</p>
<p>“My coworker doesn’t have Excel.”</p>
<p>Almost everyone used a spreadsheet program to manage data at some point in our career. These graphical programs offer a clean interface to view and manage the data we work so hard to collect. But these types of programs can also introduce problems in biological workflows.</p>
<p>There are three main issues with using Excel and other similar programs to carry out computations:</p>
<ol style="list-style-type: decimal">
<li>
<em>They can be black boxes.</em> Most spreadsheet programs are closed-source, meaning that their inner workings might not be examineable by users because the source code is not available. Exceptions to this do exist, such as Open Office. Behaviors can also vary between platforms (i.e., Macintosh vs. Windows) or across versions of the software in ways that are somewhat unpredictable.</li>
<li>
<em>You need to maintain a separate log file with your commands.</em> As we’ll see in this section, programmatically working with data provides an inherent log of all the commands you did. As long as you provide the version number of the R distribution and any libraries you’re working with, a colleague should be able to reproduce what you did exactly. By contrast, to do this in a spreadsheet program requires either writing out exactly what data were highlighted and what options were clicked on.</li>
<li>
<em>Reuse and batching is tricky.</em> When you are using a spreadsheet program, you are generally performing operations on one file at a time. Many spreadsheet programs have a system, often called macros, that allows for a series of operations to be carried out in several spreadsheet files. But you often still need to click each file to open it, and start your macro. Writing code that can be reused because it explicitly lists every operation performed allows us to process large batches of files in a way that simply isn’t possible with spreadsheet programs.</li>
</ol>
<p>In this chapter, we will discuss moving data management and analysis past the traditional spreadsheet paradigm. Along the way, we will learn about how to store data in a way that is both human- and machine-readable. Using a test dataset on ant (Formicidae) taxonomy, we will import datasets using R and begin to explore them programmatically. At the end of this chapter, you will be familiar with:</p>
<ol style="list-style-type: decimal">
<li>
<em>Concept:</em> How to store data and documentation in a way that is useful to you, colleagues and is machine-readable.</li>
<li>
<em>Concept:</em> How the Pandas R library can be used to move beyond reliance on spreadsheets.</li>
<li>
<em>Hands-On:</em> Commands to load libraries in the R language and to begin calling useful functions for data manipaltion.</li>
</ol>
</div>
<div id="storing-data" class="section level2">
<h2 class="hasAnchor">
<a href="#storing-data" class="anchor"></a>Storing Data</h2>
<p>When you save a file in Excel, you don’t simply save the data. You save, encoded in binary, information about cell positioning, coloring, and other document attributes. In the previous section, we mentioned that the behavior of a file loaded into a spreadsheet viewing program can vary between versions of the software. This is not because the data are changing. This is because there are often subtle changes to how the data are displayed or how statistics are calculated. These subtle changes can cause dramatically different renderings of files across versions and platforms.</p>
<p>All of this extraneous information also makes the file harder to read at the command line, or in R. For example, in the data directory, you will find two data files: Ants.csv and Ants.xlsx. Try looking at each in a plain text editor.</p>
<p>Which of these files are you able to visualize?</p>
<p>The Ants.csv file is stored in what is called a <em>flat file</em>. Flat files are plain text - they don’t contain any characters that can’t be typed with a keyboard, or viewed at the command line. Any fancy formatting in a plain text file comes from the viewer. For example, this book is written in plain text. The nice formatting you see is the result of rendering software. If you were to view this file at the command line, you would still be able to access all of the data within it. Because flat files can be read by both human and machine, they are often considered preferable to files with extensive encoding of extra information.</p>
<p>For the purposes of this lesson, we will show you how to get data out of spreadsheet files (such as Excel files), but we will predominantly be describing how you can avoid using these file types.</p>
<p>Inside each flat file, data should be organized with each row being an observation, and each column being the variables observed. If you open the Ants.csv file, you will note that each row corresponds to one fossil ant. Each column is labeled as a variable observed about the ant - taxonomy, age of the fossil and notes. Most programmatic ways of handling data assume this structure.</p>
<p>You will also notice that all the column names have underscores, rather than spaces. Most programming languages will assume that a space indicates the end of a name, so it’s best to avoid spaces. Lastly, notice that the data directory also contains a README. This README tells the user what data files they should expect to find when they download your data.</p>
</div>
<div id="tr" class="section level2">
<h2 class="hasAnchor">
<a href="#tr" class="anchor"></a>TR</h2>
<p>There are many ways to process data at the command line. These range from simple methods available in UNIX to elaborate and complex libraries in R. In this section, we’ll get to know Pandas a little better. We will use R as a gateway to getting familiar with R. Once we have learned how to carry out some common spreadsheet operations, we will discuss R programming more generally in the next chapter. This is by no means an exhaustive look at the Pandas library. It is simply a teaser to show some useful ways that you might interact with data in R.</p>
<p>Pandas was written by Wes McKinney to facilitate efficient data processing, manipulation and plotting in R. The fundamental data type of R is a dataframe, an object containing rows and columns of data. For our Ants.csv data, the rows will be the fossil ants. The columns will be the observations (fossil minimum ages, maximum ages, and taxonomy). It’s instructive to look at an example.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1">?read.csv</a></code></pre></div>
<p>In the command read.csv<code>, we called the function</code>read.csv` out of R’s base. We haven’t provided it with any data to read, therefore, R simply told us that the function is available via Pandas to parse text.</p>
<p>Now we will use this function to load some data into R, via the Pandas library:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1">ant_data &lt;-<span class="st">  </span><span class="kw"><a href="https://rdrr.io/r/utils/read.table.html">read.csv</a></span>(<span class="st">'data/Ants.csv'</span>)</a></code></pre></div>
<p><strong>Note for Pat and Andre: If you do this in your own workspaces, you’ll need to do:</strong></p>
<pre class="unix"><code>ant_data = pd.read_csv('../Data/Ants.csv')</code></pre>
<p>To view the data, type:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1">ant_data</a></code></pre></div>
<p>What we see is the data. We are able to call up the data to view because the data have been saved to a variable, ant_data, which was stored in memory as a dataframe when we called pd.read_csv.</p>
<blockquote>
<h3 id="challenge">Challenge:</h3>
<p>Try this command again without saving it to a variable. - What happens?</p>
<ul>
<li>Is it what you expected?</li>
<li>Why did this happen?</li>
</ul>
</blockquote>
<p>Let’s take a closer look at the ant_data object. On the face of it, it looks very much like our Excel file. Now, we’ll explore how to access data in this dataframe. Let’s start by getting a look at all the names in the file. There are a couple ways we can do this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1">ant_data[[<span class="dv">0</span>]]</a></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1">ant_data.specimen</a></code></pre></div>
<p>In our first block of code, we call the dataframe object and use what is called indexing to get the first column. Now, you may be thinking, what is going on with the notation? The brackets indicate that we will be accessing a column. R counts from zero. This may be somewhat surprising - that the language doesn’t start with one. It’s actually quite natural- you weren’t born at one year old, were you? But it still takes a little to get used to - programmers often verbally say the first item, but they mean the zeroeth item.</p>
<p>In our second block of code, we call the column by its name - specimen. This is a very natural way to access the data. We gave attributes of the data names, why not use them?</p>
<blockquote>
<h3 id="challenge-1">Challenge:</h3>
</blockquote>
<blockquote>
<p>Try accessing other columns.</p>
<ul>
<li>When will it be useful to access by name?</li>
<li>When will it not?</li>
</ul>
</blockquote>
<p>We can also select multiple columns at once using our column names.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1">ant_data[[<span class="st">'specimen'</span>, <span class="st">'tribe'</span>]]</a></code></pre></div>
<blockquote>
<h3 id="challenge-2">Challenge</h3>
<p>Try to access these same columns using their numerical index of columns. When you have an answer, highlight below to check it against my answer. Remember, R indexes values from zero, not one!</p>
</blockquote>
<blockquote>
<p>! ant_data[[0,3]]</p>
</blockquote>
<p>Selecting rows of data is also possible. The below code grab all columns in the fifth row of the dataframe:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1">ant_data[<span class="dv">5</span><span class="op">:</span><span class="dv">6</span>]</a></code></pre></div>
<p>This introduces a couple of interesting concepts. The first is using inclusive and exclusive indexing. This is an example of the 5 being inclusive - we will get the fifth row of data. The six is exclusive - we will stop accessing data at the 6th row.</p>
<p>You might notice that we are not using the specimen names as we access data. That is because, by default, Pandas assigns an index to the dataframe. We can alter this default behavior:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1">ant_data =<span class="st"> </span><span class="kw">pd.read_csv</span>(<span class="st">'data/Ants.csv'</span>, <span class="dt">index_col=</span><span class="dv">0</span>)</a></code></pre></div>
<p>This behavior sets the index to be the zeroeth column in the dataframe, the specimen column. We can now use the names of our specimens to index:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1">ant_data[<span class="st">'Casaleia_eocenica'</span><span class="op">:</span><span class="st">'Casaleia_eocenica'</span>]</a></code></pre></div>
<p>When we accession this way, the indexing is no longer inclusive. This will return the same taxon is before. In the next chapter, we will look at more efficient ways of performing this selection and slicing.</p>
<blockquote>
<h3 id="challenge-3">Challenge</h3>
</blockquote>
<blockquote>
<p>Try assigning a subset of columns to an object. Are the objects you assign what you expect, in terms of the number of rows and columns you select? Inclusive vs. exlcusive indexing can be challenging.</p>
</blockquote>
</div>
<div id="recap-our-three-goals-1" class="section level2">
<h2 class="hasAnchor">
<a href="#recap-our-three-goals-1" class="anchor"></a>Recap: Our Three Goals</h2>
<p>In this chapter, we have discussed <em>data storage</em> using flat files, which can be read by both computers and humans. We introduced R <em>libraries</em> and learned how we can call functions out of a library to do useful tasks for us. And finally, we have started to use a small set of functions in the Pandas library to access data programmatically. In the next chapter, we will build on these concepts to perform a wider range of data tasks.</p>
</div>
</div>
<div id="chapter-three-accessing-complex-combinations-of-data" class="section level1">
<h1 class="hasAnchor">
<a href="#chapter-three-accessing-complex-combinations-of-data" class="anchor"></a>Chapter Three: Accessing Complex Combinations of Data</h1>
<div id="introduction-1" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction-1" class="anchor"></a>Introduction</h2>
<p>When would we not want to use lists of columns and rows to select data out of a dataframe? When we have a lot of data, which is rapidly becoming the norm in biology. In order to process data at a large scale, we need better tools to allow us to do complex data filtering, selection and manipulation. By using R, we automatically create a log of all the operations we perform as we access our data. By the end of this chapter, you will understand:</p>
<ol style="list-style-type: decimal">
<li>
<em>Concept:</em> How the Pandas library operates to access data in a dataframe.</li>
<li>
<em>Concept:</em> How accessing data programmatically leads to reproducible research by preserving a log of your work.</li>
<li>
<em>Hands-On:</em> Commands for using Pandas to perform common spreadsheet sorting and viewing functions.</li>
</ol>
</div>
<div id="data-accession" class="section level2">
<h2 class="hasAnchor">
<a href="#data-accession" class="anchor"></a>Data Accession</h2>
<p>We will now discuss using what is called ‘slicing’ to access swaths of data in our dataframe. To do this, we will introduce two new functions, loc and iloc. loc allows for data to be accessed via either the number of the column or row, or the name of the column or row. iloc allows for data to be accessed via the column or row number only.</p>
<p>As an example, let’s try to access our same row the previous chapter:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1">ant_data.iloc[<span class="dv">5</span><span class="op">:</span><span class="dv">6</span>]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">ant_data.loc[<span class="st">'Casaleia_eocenica'</span>]</a></code></pre></div>
<p>These outputs have the same information, but they look rather different. Try assigning each output to a variable. Now, we will call the type function on each variable. For example, if I called my variables casa_iloc and casa_loc, I would type:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw"><a href="https://rdrr.io/r/base/typeof.html">type</a></span>(casa_iloc)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw"><a href="https://rdrr.io/r/base/typeof.html">type</a></span>(casa_loc)</a></code></pre></div>
<p>Type is a function that is built in to R. It allows us to know what sorts of objects our variables are, which in turn tells us about their properties. You will note that the output for the iloc function is a dataframe, with which we are familiar. The output of the loc function is a series, which we have not seen before.</p>
<p>A series is a Pandas object type. It is a one-dimensional array (i.e. not a matrix). In some ways, if a dataframe is like a spreadsheet, a series is like a single row of column in that sheet. More information on the series data type can be found by typing</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1">?c_e</a></code></pre></div>
<p>in your notebook.</p>
<p>If you type</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1">c_e.</a></code></pre></div>
<p>followed by a tab in your iR notebook, you will see a list of functions available to operate on series.</p>
<blockquote>
<h3 id="challenge-4">Challenge</h3>
</blockquote>
<blockquote>
<p>Try some of the functions available to the series and dataframe objects. When do you think it might be prefereable to use loc vs. iloc?</p>
</blockquote>
<p>Using these complex indexers, we can begin to make multiple selections of data. For example, this syntax will select all values of the subfamily column:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1">ant_data.loc[<span class="op">:</span>, <span class="st">'subfamily'</span>]</a></code></pre></div>
<p>What happens if you plug in numbers on either side of the colon to get a selection of columns? Try it!</p>
<p>Pandas doesn’t love mixed type indexing. But if you try:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1">ant_data.loc[[<span class="st">'Casaleia_eocenica'</span>,<span class="st">'Myopopone_sinensis'</span>], <span class="st">'subfamily'</span>]</a></code></pre></div>
<p>thereby passing in a list of rows that we’re interested in getting info from, you can index the data this way.</p>
<blockquote>
<h3 id="challenge-5">Challenge</h3>
</blockquote>
<blockquote>
<p>How could you print the minimum ages for all three Mianeuretus listed in this data file?</p>
</blockquote>
<p>The above is more useful and flexible than what we discussed in Chapter Two. But it’s still somewhat naive - we need to know where, exactly the data are in the file to retrieve them. We’ll now cover a few methods to allow us to sort and access data without knowing this <em>a priori</em>.</p>
<p>Something we might want to do is know which of our ants are at least as old as the KPg event, the end of the Cretaceous. Ants are thought to have arisen during the Cretaceous. We can do this easily and assign our sample of old ants to a new dataframe:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1">old_ants  =<span class="st"> </span>ant_data[ant_data.min_ma <span class="op">&gt;</span><span class="st"> </span><span class="fl">65.5</span>]</a></code></pre></div>
<p>The way this works is that we select all the values in the dataframe column min_ma that are larger than 65.5. By default, this will take the whole row. Then, we assign that to a new dataframe. We can write this dataframe to a csv file for storeage like so:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">pd.to_csv</span>(<span class="st">"output/filter_old.csv"</span>)</a></code></pre></div>
<blockquote>
<p>###Challenge</p>
</blockquote>
<blockquote>
<ul>
<li>The syntax is a little weird. Can you explain why we have dataframe typed in twice?</li>
<li>Try this again - how could we filter for ants that only existed after the end of the Creatceous? Can we use the same column?</li>
<li>When you open the parentheses on a function argument and press tab, you can see all the <em>arguments</em>, or special options, available to that function. Try a couple, such as delimiters. Once you’ve chosen an argument, Shift+Tab will show you possible values for the argument.</li>
</ul>
</blockquote>
<p>We can also use this type of indexing to compare columns. Our max_ma column should always be bigger than min_ma. We can check for rows where this isn’t the case - these are errors.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" data-line-number="1">ant_data[ant_data.min_ma <span class="op">&gt;</span><span class="st"> </span>ant_data.max_ma]</a></code></pre></div>
<p>In our data, we don’t have any such errors, but if we did, we could drop them like so:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" data-line-number="1">ant_data =<span class="st"> </span>ant_data[ant_data.min_ma <span class="op">&gt;</span><span class="st"> </span>ant_data.max_ma]</a></code></pre></div>
<p>Does anyone see a problem with what I did there?</p>
<p>I made a mistake and selected only the data that have a minimum age larger than the maximum age, and used it to overwrite the dataframe object! If I overwrote my data for real, this would be a big problem. But I didn’t - R is not doing these operations in the actual spreadsheet. It’s doing them on a dataframe held in memorey - our real data are perfectly safe in the Ants.csv file.</p>
</div>
<div id="programming-as-a-living-record-of-your-work" class="section level2">
<h2 class="hasAnchor">
<a href="#programming-as-a-living-record-of-your-work" class="anchor"></a>Programming as a Living Record of Your Work</h2>
<p>In the previous command, I switched the inequality to accidentally drop all the values I actually wanted to keep! So far, we’ve covered some important conceptual data lessons - that data are read-only, that data should be stored in flat files. We will now learn an important lesson as it pertains to code - that code can be saved for later, as an exact record of what we did in a session of programming.</p>
<p>This might not sound that important, but I think most of us have probably been working in a spreadsheet and completely forgotten how we got the useful annotations on a plot, of calculated a summary statistic. In this section, we will cover some best practices for keeping track of what we’ve done. We will expand on these best practices later, and in more complexity.</p>
<p>For now, let’s have a look at the tool we’ve been using, the Jupyter Notebook. We’ve been typing into a window in our browser. That window is running R on our computer, and rendering the output in a nice format using Java. We have code cells, which we have been pasting code into cells and running it. In these notebooks, you can create a new cell, and chenge it’s type by selecting something other than code from the dropdown. For example, we could pick ‘Markdown’ to write notes.</p>
<p>What we are doing when we do this is weaving together code and data to make readable documents that follow our whole workflow. When we are done for a session, we can select ‘Save and Checkpoint’ from the File menu. This will save our notebook for later. A notebook can be emailed to a collaborator, or, as we will cover later, managed under version control. We can also download the file as a plain R script in the File menu. We will discuss why we might want to do this in Chapter Four.</p>
<p>Together, what this means is that our code to reproduce the analysis we did is always available. If we need to go back and do it again, for example, if we get more data, that’s easy to do. We just run the code again. If a colleague wants to try the analysis again, we can simply send them the code. This is much easier than trying to explain to someone where to click to get a certain option, particularly when spreadsheet softwares are not consistent across platforms.</p>
<p>So what to do with the mistake I made? We can simply go back to our notebook and re-run the steps before I made the mistake, then fix the inequality in the equation.</p>
</div>
<div id="recap" class="section level2">
<h2 class="hasAnchor">
<a href="#recap" class="anchor"></a>Recap</h2>
<p>In this chapter, we have discussed how to programmatically access and read data using the Pandas library. We have used a variety of commands to perform simple data accession, as well as more complex choices involving multiple columns and rows. We even made a mistake in the data that we accessed - and, in the process, learned that we can use the programmatic record to reproduce the steps before we made our mistake to get our data back.</p>
</div>
</div>
<div id="chapter-four-common-spreadsheet-operations-and-how-to-automate-them" class="section level1">
<h1 class="hasAnchor">
<a href="#chapter-four-common-spreadsheet-operations-and-how-to-automate-them" class="anchor"></a>Chapter Four: Common Spreadsheet Operations and How to Automate Them</h1>
<div id="introduction-2" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction-2" class="anchor"></a>Introduction</h2>
<p>We’ve now learned a bit about how to read in data and access data in using R. This chapter will guide you through some common operations that researchers often want to do to with data using R. We will then take a step back and discuss how to use common programming conventions, like loops and lists to make automating boring tasks easier.</p>
<p>After finishing this chapter, you will usderstand:</p>
<ol style="list-style-type: decimal">
<li>
<em>Concept:</em> How data can be subsetted and sorted in the computer’s memory.</li>
<li>
<em>Concept:</em> How lists and loops can be used to perform data analysis tasks multiple times.</li>
<li>
<em>Hands On:</em> Exposure to the R language’s syntax for managing collections of objects.</li>
</ol>
</div>
<div id="subsetting-and-sorting-data" class="section level2">
<h2 class="hasAnchor">
<a href="#subsetting-and-sorting-data" class="anchor"></a>Subsetting and Sorting Data</h2>
<p>One common task many researchers do with their data is break it into smaller chunks, perhaps by treatment, to look at effects in that group. We’re not working with experiemental data here, but we can certainly split our data up. Ants are known in the literature as the Formicids. This is a family. There are many subfamilies of ants. We might be interested in seeing if we have equal samples of each subfamily.</p>
<p>We can group our data by subfamily like so:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" data-line-number="1">sub_fams =<span class="st"> </span><span class="kw">ant_data.groupby</span>(<span class="st">'subfamily'</span>)</a></code></pre></div>
<p>Doing this creates a groupby object, or a list of chunks of our data, identified by the subfamily to which they belong. We can view them like so:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="cf">for</span> fam <span class="cf">in</span> sub_fams<span class="op">:</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="kw"><a href="https://rdrr.io/r/base/print.html">print</a></span>(fam)</a></code></pre></div>
<p>Congratulations, you’ve written your first loop. What this loop does is, for every object in sub_fams, R prints the object to the screen. print() is a R function available in all installations of R (version 3.0+). ‘fam’ is what is known as a <em>loop variable</em>. R automatically assumes that, if sub_fams is an object containing other objects, that fam will be the smallest unit of the sub_fams container. In other languages, you might have to assign the loop variable before using it, but R is pretty smart about figuring out what it is.</p>
<p>Our original question was if all of the groups are about the same size. So let’s answer it:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">sub_fams.size</span>()</a></code></pre></div>
<p>They are not. The samples of Formicinae and Dolichoderinae, for example, are much bigger than the rest. These are also the most specious groups of ants. Could the disparity in the sample be due to group speciousity? I’ve made a secodn spreadsheet with a rough guess at the species richness of each of the ant groups in this data set. Let’s load it:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" data-line-number="1">sub_r =<span class="st"> </span><span class="kw">pd.read_csv</span>(<span class="st">'data/subfamilyRichness.csv'</span>, <span class="dt">index_col=</span><span class="dv">0</span>)</a></code></pre></div>
<p>You’ll notice we’ve added a new option to reading in a csv file - index_col. This allows us to specifiy which column we would like to be the index. In this case, we want the subfamily names to be the index.</p>
<p>To get these two data sources together, we need to do some massaging of our data. Groupby objects can be turned into dataframes in which the index is the groupname (in our case, the subfamily) and the data are the sizes of the group like so:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb25-1" data-line-number="1">sizes =<span class="st"> </span><span class="kw">pd.DataFrame</span>(<span class="kw">sub_fams.size</span>())</a></code></pre></div>
<p>But this actually gives us a multi-level index that is unsuitable for our purposes. I’m going to have us reset the index to the names of the subfamilies. We’re going to do this first by looping over our groupby objects and getting the names of the groups (the subfamily) and putting those in a list. We do this by first creating the list. Then, we initialize our loop. And we take the first value in each groupby group, which is the name of the group.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" data-line-number="1">names =<span class="st"> </span>[]</a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="cf">for</span> fam <span class="cf">in</span> sub_fams<span class="op">:</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3"><span class="st">  </span><span class="kw">names.append</span>(fam[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">sizes.reset_index</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">sizes.index =<span class="st"> </span>names</a></code></pre></div>
<p>Once we have executed the loop, we erase the index that exists and reset it to our group names.</p>
<blockquote>
<p>###Challenge</p>
</blockquote>
<blockquote>
<ul>
<li>Try calling functions of the groupby objects, for example, mean() on the sub_fams object. What would these types of functions be helpful for? Remember, once you’ve typed in sub_fams. and hit tab, you can see available methods.</li>
</ul>
</blockquote>
</div>
<div id="merging-and-using-data" class="section level2">
<h2 class="hasAnchor">
<a href="#merging-and-using-data" class="anchor"></a>Merging and Using Data</h2>
<p>Now we have two dataframes, one with our observed data and one with the number of species that exist in nature. To do mathematical operations using both pieces of data, we will combine them. We will do this using a merge, which combines two datasets on a given column:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb27-1" data-line-number="1">new_sizes=<span class="st"> </span><span class="kw">sizes.merge</span>(sub_r, <span class="dt">left_index=</span>True, <span class="dt">right_index=</span>True)</a></code></pre></div>
<p>In our case, we will merge sizes to sub_r. We will use the nice indices we just created as our join columns. This is specified by ‘left_index’, the index of the object before we call the merge function being set to true, and right_index, the index of the object after we call the merge being set to true. If we had called join with sub_r being first, it would be the left and sizes would be the right.</p>
<p>The output of this is a new dataframe, with two columns: one from sizes, one from sub_r. We can now divide out our two columns to see if we have sampled some clades more because they are more speciose. If this were true, we would expect to see roughly the same proportion of sampling, but not the same number of samples. We will assign the sampling proportion to a new column called ‘proportion’.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb28-1" data-line-number="1">new_sizes[<span class="st">'proportion'</span>] =<span class="st"> </span>new_sizes.reps<span class="op">/</span>new_sizes.size</a></code></pre></div>
<p>Do these sizes look right? Your answer should be no. It turns out that ‘size’ is a reserve word, and calls a function called size. This function returns the size of each object in bytes. So instead of dividing each entry in reps by each entry in size we’re dividing by bytes. But that’s OK, we can rename our columns on the fly:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb29-1" data-line-number="1">new_sizes.columns =<span class="st"> </span>[<span class="st">'reps'</span>,<span class="st">'num_spec'</span>,<span class="st">'prop'</span>]</a></code></pre></div>
<p>Now try it:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" data-line-number="1">new_sizes[<span class="st">'proportion'</span>] =<span class="st"> </span>new_sizes.reps<span class="op">/</span>new_sizes.num_spec</a></code></pre></div>
<p>Much better!</p>
<blockquote>
<p>###Challenge - Try some other mathematical operations. Subtract the columns! - How could you delete a column if you decided you didn’t want your mathematical output? (Hint: look at the drop function. Be aware some behaviors are a little odd.) - Think a little about data as read-only: where will you want to save these outputs?</p>
</blockquote>
<p>## Recap</p>
<p>In this chapter, we have looked at subsetting our data. We used the groupby command to make data subsets along a biologically interesting axis. We then used loops and lists to process data and make the process of managing datasets easier. Finally, we joined together multiple data objects and used them to perform mathematical operations. In the next chapter, we will build on the concepts seen here to further automate data management.</p>
</div>
</div>
<div id="chapter-five-functions-scripts-and-revision-management" class="section level1">
<h1 class="hasAnchor">
<a href="#chapter-five-functions-scripts-and-revision-management" class="anchor"></a>Chapter Five: Functions, Scripts and Revision Management</h1>
<p>So far, we’ve covered the nuts and bolts of programming. We’ve learned a little bit about how to control R, and it’s time to think about controlling its environment. As you program more and more, you’ll need to have maintainable pieces of code, and some framework to maintain them.</p>
<p>In this chapter, we’ll cover three core concepts. <em>Functions</em>, which are blocks of code that work together to achieve some purpose. We will discuss <em>scripts</em>, which may contain one or more functions and the comments needed to interpret and use them. And lastly, we will discuss <em>revision management</em>, the practice of using a defined system to track how and when changes are made to your code.</p>
<p>By the end of this chapter, you will be able to:</p>
<ol style="list-style-type: decimal">
<li>
<em>Concept:</em> Explain why and how functions can be used to make code more maintainable.</li>
<li>
<em>Concept:</em> How grouping functions into scripts can make it easier to understand and maintain code.</li>
<li>
<em>Concept &amp; Hands-On:</em> Commands to use a revision management system to keep track of changes to your codebase.</li>
</ol>
<div id="functions" class="section level2">
<h2 class="hasAnchor">
<a href="#functions" class="anchor"></a>Functions</h2>
<p>We’ve previously introduced functions in the context of calling functions from a package, like calling read_csv from Pandas. We’re now going to discuss making our own functions to do everyday operations that we need.</p>
<p>We can think of a function like an organ of the body - a function is a grouping of code that performs a task. For example, we might write a function that extracts relevant rows from a dataframe and writes them to a file. That’s a great idea - let’s do that here in a second.</p>
<p>Why would we want to write functions, instead of just stuffing all our code into a file? There are several reasons. Functions provide a natural grouping for blocks of code. This makes it easier, just visually, to see what types of operations our code can do. And programming can be tricky - anything to make it easier will help us. Functions also have defined in and outputs. For example, a function that grabs columns from a dataframe might first check that the dataframe exists, and check that the file you’re trying to write your data to doesn’t exist so you don’t overwrite good data. In this way, functions make it possible for us to better check that our code is working as expected.</p>
<p>Let’s start by defining our function. The definition statement names the function and tells us what toexpect as input to that function. Without the right input, the code will stop executing. A definition statement looks like this:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb31-1" data-line-number="1">def <span class="kw">extract_rows</span>(file, ant_names)<span class="op">:</span></a></code></pre></div>
<p>This definition statement is for a function named extract_rows. This function takes as input a variable called data. I think you can guess where this is going - data will be the name of a dataframe from which we will extract the rows. It also takes as input a list of names of ants that we would like to extract. Recall that our rows in the dataframe are ant species.</p>
<p>The next thing that comes after the function definition is the docstring, or a comment that explains the purpose of the function.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" data-line-number="1">def <span class="kw">extract_rows</span>(data, ant_names)<span class="op">:</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2"><span class="st">    '''A function to extract relevant data from dataframe'''</span></a></code></pre></div>
<p>Next comes the body of the function, or the actual code. In the data directory, I have added a file called AntTestData.txt, containing a number of ant specimen names. These are the ants we would like to call out of our dataframe. We’ll talk in a moment about how to read in a non-CSV text file. For now, write a little bit of code that will pull a single row based on an ant name - let’s try Amblyopone_pallipes. Then check your answer below.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" data-line-number="1">def <span class="kw">extract_rows</span>(data, ant_names)<span class="op">:</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2"><span class="st">    '''A function to extract relevant data from dataframe'''</span></a>
<a class="sourceLine" id="cb33-3" data-line-number="3">    new_data =<span class="st"> </span>data.loc[<span class="st">'Amblyopone_pallipes'</span>]</a></code></pre></div>
<p>But we don’t just want one name, we want a bunch of names. And what we have done above is called <em>hard-coding</em>. Hard coding is undesireable because it means that every time we want to use different data, we have to change the code. That is dangerous. So what we want to do is rewrite this function to take a bunch of names and fetch them from our data frame.</p>
<p>So let’s get ourselves a list of ant names.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb34-1" data-line-number="1">def <span class="kw">get_names</span>(namefile)<span class="op">:</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="st">    '''Read in a file of names'''</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    with <span class="kw"><a href="https://rdrr.io/r/base/connections.html">open</a></span>(namefile, <span class="st">'r'</span>) as f<span class="op">:</span></a>
<a class="sourceLine" id="cb34-4" data-line-number="4"><span class="st">        </span>ant_names =<span class="st"> </span><span class="kw">f.read</span>()<span class="kw">.splitlines</span>()</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">    <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span>(ant_names)</a></code></pre></div>
<p>Above, we have added one more function piece - the return statement. The return statement allows us to preserve objects after the function is done running. In this case, we can pass the list of ant names out of the function. The above code does a lot of stuff. First, it takes as input a file of ant names. It uses a with statement to open the file, then uses a function called read to get the data out. Our data have newlines at the end - that’s what causes each ant name to be on its own line when we open the file in a text editor. But that will cause the ant names to not be found in our dataframes, since the dataframe doesn’t have newlines. Splitlines takes these off. Finally, we return the list of names.</p>
<p>So now we have two functions, one to get our ant names and one to use the ant names to look up ants in the database. Let’s rewrite our dataframe function to take a list of names.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb35-1" data-line-number="1">def <span class="kw">extract_rows</span>(data, ant_names)<span class="op">:</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2"><span class="st">  '''A function to extract relevant data from dataframe'''</span></a>
<a class="sourceLine" id="cb35-3" data-line-number="3">new_data =<span class="st"> </span>data.loc[ant_names]</a>
<a class="sourceLine" id="cb35-4" data-line-number="4"><span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span>(new_data)</a></code></pre></div>
<p>Our function is complete! We have two functions, both of which are doing use_ful_ and interesting things. Now, let’s look at how to make them use_able_ by scripting them into a R program.</p>
</div>
<div id="r-scripts" class="section level2">
<h2 class="hasAnchor">
<a href="#r-scripts" class="anchor"></a>R Scripts</h2>
<p>We can write functions all day, but they don’t run unless called - that is, unless we use their names to invoke them. Now, we will cover how to do this. As of right now, we have two functions:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb36-1" data-line-number="1">def <span class="kw">extract_rows</span>(data, ant_names)<span class="op">:</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="st">'''A function to extract relevant data from dataframe'''</span></a>
<a class="sourceLine" id="cb36-3" data-line-number="3">new_data =<span class="st"> </span>data.loc[ant_names]</a>
<a class="sourceLine" id="cb36-4" data-line-number="4"><span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span>(new_data)</a>
<a class="sourceLine" id="cb36-5" data-line-number="5"></a>
<a class="sourceLine" id="cb36-6" data-line-number="6">def <span class="kw">get_names</span>(namefile)<span class="op">:</span></a>
<a class="sourceLine" id="cb36-7" data-line-number="7"><span class="st">'''Read in a file of names'''</span></a>
<a class="sourceLine" id="cb36-8" data-line-number="8">with <span class="kw"><a href="https://rdrr.io/r/base/connections.html">open</a></span>(namefile, <span class="st">'r'</span>) as f<span class="op">:</span></a>
<a class="sourceLine" id="cb36-9" data-line-number="9">ant_names =<span class="st"> </span><span class="kw">f.read</span>()<span class="kw">.splitlines</span>()</a>
<a class="sourceLine" id="cb36-10" data-line-number="10"><span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span>(ant_names)</a></code></pre></div>
<p>Open your text editor and past in these two functions.</p>
<p>Before your functions, include the line:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb37-1" data-line-number="1">import pandas as pd</a></code></pre></div>
<p>to import Pandas for your script.</p>
<p>Now, we will build our function calls.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb38-1" data-line-number="1"></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="cf">if</span> __name__ <span class="op">==</span><span class="st"> '__main__'</span><span class="op">:</span></a>
<a class="sourceLine" id="cb38-3" data-line-number="3"><span class="st">  </span>data =<span class="st"> </span><span class="kw">pd.read_csv</span>(<span class="st">'Data/Ants.csv'</span> <span class="dt">index_col=</span><span class="dv">0</span>)</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">namefile =<span class="st"> 'Data/AntTestData.txt'</span></a>
<a class="sourceLine" id="cb38-5" data-line-number="5">ant_names =<span class="st"> </span><span class="kw">get_names</span>(namefile)</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">new_dataframe =<span class="st"> </span><span class="kw">extract_rows</span>(data, ant_names)</a>
<a class="sourceLine" id="cb38-7" data-line-number="7"><span class="kw">new_dataframe.to_csv</span>(<span class="st">'Data/processed_ants.csv'</span>)</a></code></pre></div>
<p>This is an odd-looking statement. But in a script the name statement allows us to tell R which functions to actually call. If we had extra functions that we didn’t want to execute, we could just leave them out.</p>
<p>Save this as first_script.py. In the git bash terminal, navigate to where you have saved the script (hopefully in the Spring2017 directory) and type:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb39-1" data-line-number="1"></a>
<a class="sourceLine" id="cb39-2" data-line-number="2">R first_script.py</a></code></pre></div>
<p>You should see a 5-row dataframe pop out.</p>
<p>But we’ve done something bad. Remember how we said that hard coding was not optimal? They still aren’t. So let’s think about how to get rid of the hard coding. See how I had you import a mystery modeule - sys? Sys allows us to pass in additional information from the command line. We can use the arg function to take in command-line arguments: if <strong>name</strong> == ‘<strong>main</strong>’: data = pd.read_csv(sys.argv[1] index_col=0) namefile = sys.argv[2] ant_names = get_names(namefile) new_dataframe = extract_rows(data, ant_names) new_dataframe.write_to_csv(sys.argv[3]) ```</p>
<p>Now, when we call this script, we type:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb40-1" data-line-number="1"></a>
<a class="sourceLine" id="cb40-2" data-line-number="2">R first_script.py Data<span class="op">/</span>Ants.csv Data<span class="op">/</span>AntTestData.txt Data<span class="op">/</span>ant_processed.csv</a></code></pre></div>
<p>Now, if we want to change the name of the output file, we just change the last argument at the command line. Need a different set of ants? Change the taxon list. Easy. No changing the code for every analysis.</p>
<p>One final thing. Remember that data are read-only? We really oughtn’t be writing to our data directory. Let’s add just one more function. Add an import statement for the os library, which allows us to manipulate file paths:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb41-1" data-line-number="1">import os</a></code></pre></div>
<p>Now we will write a function to us os to check if an output directory exists, and if not, to create it:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb42-1" data-line-number="1">def <span class="kw">check_dir</span>(path)<span class="op">:</span></a>
<a class="sourceLine" id="cb42-2" data-line-number="2">check =<span class="st"> </span><span class="kw">path.split</span>(<span class="st">'/'</span>)[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb42-3" data-line-number="3"><span class="kw">os.listdir</span>(check)</a>
<a class="sourceLine" id="cb42-4" data-line-number="4"><span class="cf">if</span> <span class="st">'output'</span> <span class="cf">in</span> <span class="kw">os.listdir</span>(check)<span class="op">:</span></a>
<a class="sourceLine" id="cb42-5" data-line-number="5">return</a>
<a class="sourceLine" id="cb42-6" data-line-number="6"><span class="cf">else</span><span class="op">:</span></a>
<a class="sourceLine" id="cb42-7" data-line-number="7"><span class="kw">os.mkdir</span>(<span class="st">'%s/output'</span> % check)</a></code></pre></div>
<blockquote>
<h3 id="challenge-6">Challenge:</h3>
<ol style="list-style-type: decimal">
<li>Add a function call for check_dir to the main statement.</li>
<li>Explain why check_dir does not have a return statement at the very end.</li>
<li>How will you need to modify your invocation of the R script to make sure your output is written to the right place.</li>
<li>What is split doing?</li>
<li>Write a docstring for this function.</li>
</ol>
</blockquote>
</div>
<div id="revision-management" class="section level2">
<h2 class="hasAnchor">
<a href="#revision-management" class="anchor"></a>Revision Management</h2>
<p>Now we have an actual, working script. This is fantastic - we can send this to a coworker and have them reproduce our analyses. We can use it again later to recall exactly what we did!</p>
<p>Until our coworker emails it back and says it doesn’t work, and we open it to find a bunch of changes. Until we accidentally delete a piece of code, close our laptop, and go on vacation. Until our laptop dies.</p>
<p>Enter revision management, for tracking changes to our code (or any other text file - this tutorial was written with revision management). As you’re aware, we will be using git for revision management this semester. What we’re going to do now is a really swift primer on some of the basic functionality of git and its web interface, GitHub.</p>
<p>First, we’ll do some brief setup:</p>
<pre><code>git config --global user.name "Your Name"
$ git config --global user.email "you@youremail"</code></pre>
<p>When you do the setup, use the email address you set up GitHub with. That way, GitHub will know the commits are from you and won’t reject them (I have added you as collaborators on my project).</p>
<p>I really want you to protect the script we just wrote together. First, add your initials to the name of your script so I know whose is whose. Mine would be first_script_amw.py. Now, in the Spring2017 directory, type:</p>
<pre><code>git add first_script_yourinitials.py</code></pre>
<p>This command lets git know that we’re interested in tracking any changes made to this script. Next, we want to commit the script. Committing takes a snapshot of the script, preserving it as it existed in that moment in time. People differ on how often to commit. Some people commit frequently, some people only commit when they are done for the day.</p>
<pre><code>git commit</code></pre>
<p>This will now ask you for a short message describing what is being committed. You could say something like ‘adding ant data parsing script’ or ‘initial draft of script’. Try for something informative.</p>
<p>Now, we push to the internet:</p>
<pre><code>git push</code></pre>
<p>This may ask you for your username and password, if you cloned the repository over HTTPS. Once this has completed, you should be able to go to the website for the repository and look at your script!</p>
<p>You might be wondering now where git is storing your log of revisions. If you go up one level like so:</p>
<pre><code>
cd ..</code></pre>
<p>and list hidden files:</p>
<pre><code>ls -a</code></pre>
<p>you will see a folder called .git. This stores all your checkpoints and snapshots.</p>
<p>We’ll cover more complex Git functionality in the future as we do more work.</p>
<blockquote>
<h3 id="challenge-7">Challenge</h3>
<p>Try to find a tpyo to fix in the lessons. Fix it, add the file in git, commit it and push it.</p>
</blockquote>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">

        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li>
<a href="#chapter-one-an-introduction-to-project-organization">Chapter One: An Introduction to Project Organization</a><ul class="nav nav-pills nav-stacked">
<li><a href="#introduction-how-can-we-maintain-tractable-data-structures-for-use-with-phylogenetic">Introduction: How can we maintain tractable data structures for use with phylogenetic</a></li>
      <li><a href="#creating-project-workspaces">Creating Project Workspaces</a></li>
      </ul>
</li>
      <li>
<a href="#chapter-two-moving-from-spreadsheets-to-r">Chapter Two: Moving From Spreadsheets to R</a><ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li><a href="#storing-data">Storing Data</a></li>
      <li><a href="#tr">TR</a></li>
      <li><a href="#recap-our-three-goals-1">Recap: Our Three Goals</a></li>
      </ul>
</li>
      <li>
<a href="#chapter-three-accessing-complex-combinations-of-data">Chapter Three: Accessing Complex Combinations of Data</a><ul class="nav nav-pills nav-stacked">
<li><a href="#introduction-1">Introduction</a></li>
      <li><a href="#data-accession">Data Accession</a></li>
      <li><a href="#programming-as-a-living-record-of-your-work">Programming as a Living Record of Your Work</a></li>
      <li><a href="#recap">Recap</a></li>
      </ul>
</li>
      <li>
<a href="#chapter-four-common-spreadsheet-operations-and-how-to-automate-them">Chapter Four: Common Spreadsheet Operations and How to Automate Them</a><ul class="nav nav-pills nav-stacked">
<li><a href="#introduction-2">Introduction</a></li>
      <li><a href="#subsetting-and-sorting-data">Subsetting and Sorting Data</a></li>
      <li><a href="#merging-and-using-data">Merging and Using Data</a></li>
      </ul>
</li>
      <li>
<a href="#chapter-five-functions-scripts-and-revision-management">Chapter Five: Functions, Scripts and Revision Management</a><ul class="nav nav-pills nav-stacked">
<li><a href="#functions">Functions</a></li>
      <li><a href="#r-scripts">R Scripts</a></li>
      <li><a href="#revision-management">Revision Management</a></li>
      </ul>
</li>
      </ul>
</div>
      </div>

</div>



      <footer><div class="copyright">
  <p>Developed by The package maintainer.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.4.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
